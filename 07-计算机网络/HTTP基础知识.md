# HTTP 基础篇
## 什么是HTTP？  
粗略地回答是：HTTP 是超文本传输协议。  
但是这里其实是可以进一步解释的，就是对```超文本传输协议```这几个字进行展开说明。划分为三块，超文本、传输、协议。  
  > `超文本`：顾名思义，就是超越普通的文本。普通的文本是指一些字符、文字，这里的超越文本是指一些图片、视频等混合体。  
  > `传输`：传输就要有发送对象和接收对象，同时发送对象反过来也可以作为接收对象，说明 HTTP 是一个双向协议，是在计算机世界中专门用来在两点之间传输数据的  
  > `协议`：大家都遵守的东西(约定和规范)就叫协议。  

**准确答案**：HTTP 是一个在计算机世界里专门在**两点之**间**传输**文字、图片、音频、视频等**超文本**数据的**约定和规范**。

## HTTP常见的状态码有哪些？  
~~1xx: 提示信息。表示处于协议处理的中间状态, 后续还有操作。（用得少也考得少）~~  
2xx: 成功。服务器成功处理了客户端的请求  
  >```200 OK```. 表示一切正常。如果是⾮ HEAD 请求，服务器返回的响应头会有 body数据  
  >```204 No Content```. 与 200 OK 基本相同，但响应头没有 body 数据  
  >```206 Partial Content```. 表示响应返回的 body 数据并不是资源的全部，只是其中的一部分。Partial Content是部分内容的意思。  

3xx: 重定向。服务器检测到资源位置发生了变动，需要客户端重新发送请求  
  > `301 Moved Permanently` 表示永久重定向，说明请求的资源已经不存在了，需改用全新的url来访问。Permanently是永久的意思。  
  > `302 Found` 表示临时重定向，说明请求的资源还存在，但是展示需要用另一个url来访问。  
  > 301 和 302 都会在响应头⾥使⽤字段 `Location` ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。  
  > `304 Not Modified` 表示资源未修改。重定向(访问)已存在的缓冲文件。Modified是修改的意思

4xx: 客户端错误。服务器无法处理，因为客户端发送的报文有误  
  > `400 Bad Request` 表示客户端请求的报文有错误  
  > `403 Forbidden` 表示服务器禁⽌访问资源，并不是客户端的请求出错  
  > `404 Not Found` 表示请求的资源在服务器上不存在或未找到
    
5xx: 服务端错误。服务器处理报文时内部发生错误，客户端方面没问题(客户端请求报文正确)。
  > `500 Internal Server Error` 表示服务器发生错误，具体什么错误，我们并不知道，非常笼统。
  > `501 Not Implemented` 表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。Implemented是落实、生效的意思。  
  > `502 Bad Gateway` 表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。Gateway 是网关,途径的意思。  
  > `503 Service Unavailable` 表示服务器繁忙，暂时无法作出响应。类似“网络服务正忙，请稍后重试”的意思。 Unavailable 的意思是无法得到、难以获得

## http 常见字段有哪些？
Host 字段：客户端发送请求时，⽤来指定服务器的域名  
Content-Length 字段：服务器在返回数据时，表明本次回应的数据⻓度  
Content-Type 字段: ⽤于服务器回应时，告诉客户端，本次数据是什么格式。客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式  
Content-Encoding 字段：数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式。客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法

## GET 和 POST 有什么区别？
Get ⽅法的含义是请求从服务器**获取**资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频  
⽽ POST ⽅法则是相反操作，它向 URI 指定的资源**提交**数据，数据就放在报⽂的 body ⾥。

## GET 和 POST ⽅法都是安全和幂等的吗？  
在 HTTP 协议里，所谓的`安全`是指请求⽅法**不会破坏服务器上的资源**。`幂等`是指多次执⾏相同的操作，**结果都是相同的**。这个可以用JavaScript中的纯函数来解释，即相同的输入必定会得到相同的输出。  
很明显 GET ⽅法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。  
POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的

## HTTP 优缺点
### HTTP 的优点是什么？怎么体现？
HTTP 最凸出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。  
`简单` = HTTP 的报文简单
> HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习和使⽤的⻔槛。

> 什么是报文？  
> 报文是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变

`灵活和易于扩展` = HTTP 协议里每个组成要求都没有固定死
> HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充

`应⽤⼴泛和跨平台` = 台式机、浏览器、手机都能使用
> 互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。

### HTTP 的缺点是什么？
HTTP ⽐较严重的缺点就是不安全:  
> 通信使⽤明⽂（不加密），内容可能会被窃听。  
> 不验证通信⽅的身份，因此有可能遭遇伪装。  
> ⽆法证明报⽂的完整性，所以有可能已遭篡改。  

HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极致  

### HTTP 性能如何？
HTTP协议是基于 TCP/IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥，请求的能力怎么样，应答的能力怎么样。以HTTP1.1为例:  
> HTTP1.1使用的是长连接的通信方式(connection: keep-alive)，解决了http1.0在性能上的一个很大的问题(就是每发起一个请求，就要新建一次TCP连接)。  

> 长连接又叫持久连接，它的特点就是只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。依据这个特点，实现了管道网络运输，即在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。  

> 「请求 - 应答」的模式加剧了 HTTP 的性能问题。因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据，这也就是「队头阻塞」。  

> 总之 HTTP/1.1 的性能⼀般般, 不然也不会有HTTP2、HTTP3了，每一次协议的更新都是为了解决前面的协议存在的问题，要是前面的协议是完美无敌的，那就不必再提出新的协议的了。


## HTTP 与 HTTPS 有哪些区别？
1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。  
2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。  
3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。  
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。  

## HTTPS 解决了 HTTP 的哪些问题？
HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：  
> 窃听⻛险、篡改⻛险、冒充⻛险  

[解决办法](./02-HTTP%E7%AF%87/2.3%20RSA%E6%96%87%E5%AD%97%E8%A7%A3%E6%9E%90.md)  

## HTTPS 是如何建⽴连接的？其间交互了什么？
HTTPS 是在 HTTP 的基础上引入了SSL(又叫TLS)用来加密确保安全，SSL/TLS 协议基本流程如下：  
> 客户端向服务器索要并验证服务器的公钥。  
> 双⽅协商⽣产「会话秘钥」。  
> 双⽅采⽤「会话秘钥」进⾏加密通信。  

前两步也就是 SSL/TLS 的建⽴过程，也就是握⼿阶段。具体介绍点击[这里](./02-HTTP%E7%AF%87/2.3%20RSA%E6%96%87%E5%AD%97%E8%A7%A3%E6%9E%90.md)跳转

# HTTP/1.1、HTTP/2、HTTP/3 演变
## HTTP/1.1 相⽐ HTTP/1.0 提⾼了什么性能？
HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：  
> 使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销  
> ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

HTTP/1.1 还是有性能瓶颈(缺陷)：  
> 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分  
> 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多  
> 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞  
> 没有请求优先级控制  
> 请求只能从客户端开始，服务器只能被动响应。  

## 为了解决上⾯的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？
HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。  
那 HTTP/2 相⽐ HTTP/1.1 性能上的改进：  
`头部压缩`  
> HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。  
> 这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。  

`⼆进制格式`  
> HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧。  
> 这样虽然对⼈不友好，但是对计算机⾮常友好，因为计算机只懂⼆进制，那么收到报⽂后，⽆需再将明⽂的报⽂转成⼆进制，⽽是直接解析⼆进制报⽂，这增加了数据传输的效率。  

![⼆进制格式](https://cdn.jsdelivr.net/gh/jsdevin/imgBed/img/202205210131368.png)

`数据流`  
> HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。  
每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数  
客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。  

`多路复⽤`  
> HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。  
> 移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼了连接的利⽤率。  
> 举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。  

`服务器推送`  
> HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发送消息。  
> 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。  

## HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？
HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。  
> HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了  
> HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。   

这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！  
UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全部重传问题。  
⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。  
> QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。
> TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。
> HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。  

![](https://cdn.jsdelivr.net/gh/jsdevin/imgBed/img/202205210138911.png)  

所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤的协议。  
QUIC 是新协议，对于很多⽹络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以HTTP/3 现在普及的进度⾮常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。
